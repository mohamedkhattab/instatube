{:rename-macros {}, :renames {}, :externs {Error {}}, :use-macros {assert-js-object reagent.debug, assert-some reagent.debug, assert-new-state reagent.debug, dbg reagent.debug, $! reagent.interop, prn reagent.debug, assert-component reagent.debug, $ reagent.interop, assert-callable reagent.debug}, :excludes #{atom flush partial}, :name reagent.core, :imports nil, :requires {reagent.impl.util reagent.impl.util, dom reagent.dom, comp reagent.impl.component, reagent.interop reagent.interop, reagent.ratom reagent.ratom, react react, reagent.impl.template reagent.impl.template, reagent.impl.batching reagent.impl.batching, reagent.impl.component reagent.impl.component, util reagent.impl.util, tmpl reagent.impl.template, ratom reagent.ratom, deb reagent.debug, batch reagent.impl.batching, reagent.debug reagent.debug, reagent.dom reagent.dom}, :cljs.spec/speced-vars [], :uses nil, :defs {after-render {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 330, :column 7, :end-line 330, :end-column 19, :arglists (quote ([f])), :doc "Run f using requestAnimationFrame or equivalent.\n\n  f will be called just after any queued renders in the next animation\n  frame (and even if no renders actually occur)."}, :name reagent.core/after-render, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 19, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 330, :end-line 330, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Run f using requestAnimationFrame or equivalent.\n\n  f will be called just after any queued renders in the next animation\n  frame (and even if no renders actually occur)."}, current-component {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 121, :column 7, :end-line 121, :end-column 24, :arglists (quote ([])), :doc "Returns the current React component (a.k.a this) in a component\n  function."}, :name reagent.core/current-component, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 24, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 121, :end-line 121, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Returns the current React component (a.k.a this) in a component\n  function."}, as-component {:name reagent.core/as-component, :file "resources/public/js/cljs-dev/reagent/core.cljs", :line 84, :column 1, :end-line 84, :end-column 18, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 84, :column 6, :end-line 84, :end-column 18}}, adapt-react-class {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 50, :column 7, :end-line 50, :end-column 24, :arglists (quote ([c])), :doc "Returns an adapter for a native React class, that may be used\n  just like a Reagent component function or class in Hiccup forms."}, :name reagent.core/adapt-react-class, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 24, :method-params ([c]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 50, :end-line 50, :max-fixed-arity 1, :fn-var true, :arglists (quote ([c])), :doc "Returns an adapter for a native React class, that may be used\n  just like a Reagent component function or class in Hiccup forms."}, atom {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 209, :column 7, :end-line 209, :end-column 11, :arglists (quote ([x] [x & rest])), :doc "Like clojure.core/atom, except that it keeps track of derefs.\n  Reagent components that derefs one of these are automatically\n  re-rendered.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([x]), :arglists ([x] [x & rest]), :arglists-meta (nil nil)}}, :name reagent.core/atom, :variadic true, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([x]), :arglists ([x] [x & rest]), :arglists-meta (nil nil)}, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 209, :end-line 209, :max-fixed-arity 1, :fn-var true, :arglists ([x] [x & rest]), :doc "Like clojure.core/atom, except that it keeps track of derefs.\n  Reagent components that derefs one of these are automatically\n  re-rendered."}, merge-props {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 191, :column 7, :end-line 191, :end-column 18, :arglists (quote ([defaults props])), :doc "Utility function that merges two maps, handling :class and :style\n  specially, like React's transferPropsTo."}, :name reagent.core/merge-props, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 18, :method-params ([defaults props]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 191, :end-line 191, :max-fixed-arity 2, :fn-var true, :arglists (quote ([defaults props])), :doc "Utility function that merges two maps, handling :class and :style\n  specially, like React's transferPropsTo."}, force-update-all {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 87, :column 16, :end-line 87, :end-column 32, :export true, :arglists (quote ([])), :doc "Force re-rendering of all mounted Reagent components. This is\n  probably only useful in a development environment, when you want to\n  update components in response to some dynamic changes to code.\n\n  Note that force-update-all may not update root components. This\n  happens if a component 'foo' is mounted with `(render [foo])` (since\n  functions are passed by value, and not by reference, in\n  ClojureScript). To get around this you'll have to introduce a layer\n  of indirection, for example by using `(render [#'foo])` instead."}, :name reagent.core/force-update-all, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 32, :method-params ([]), :protocol-impl nil, :export true, :arglists-meta (nil nil), :column 1, :line 87, :end-line 87, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Force re-rendering of all mounted Reagent components. This is\n  probably only useful in a development environment, when you want to\n  update components in response to some dynamic changes to code.\n\n  Note that force-update-all may not update root components. This\n  happens if a component 'foo' is mounted with `(render [foo])` (since\n  functions are passed by value, and not by reference, in\n  ClojureScript). To get around this you'll have to introduce a layer\n  of indirection, for example by using `(render [#'foo])` instead."}, as-element {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 44, :column 7, :end-line 44, :end-column 17, :arglists (quote ([form])), :doc "Turns a vector of Hiccup syntax into a React element. Returns form\n  unchanged if it is not a vector."}, :name reagent.core/as-element, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 17, :method-params ([form]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 44, :end-line 44, :max-fixed-arity 1, :fn-var true, :arglists (quote ([form])), :doc "Turns a vector of Hiccup syntax into a React element. Returns form\n  unchanged if it is not a vector."}, rswap! {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 302, :column 7, :end-line 302, :end-column 13, :arglists (quote ([a f & args])), :doc "Swaps the value of a to be (apply f current-value-of-atom args).\n\n  rswap! works like swap!, except that recursive calls to rswap! on\n  the same atom are allowed – and it always returns nil.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(a f args)], :arglists ([a f & args]), :arglists-meta (nil)}}, :name reagent.core/rswap!, :variadic true, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(a f args)], :arglists ([a f & args]), :arglists-meta (nil)}, :method-params [(a f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 302, :end-line 302, :max-fixed-arity 2, :fn-var true, :arglists ([a f & args]), :doc "Swaps the value of a to be (apply f current-value-of-atom args).\n\n  rswap! works like swap!, except that recursive calls to rswap! on\n  the same atom are allowed – and it always returns nil."}, next-tick {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 323, :column 7, :end-line 323, :end-column 16, :arglists (quote ([f])), :doc "Run f using requestAnimationFrame or equivalent.\n\n  f will be called just before components are rendered."}, :name reagent.core/next-tick, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 16, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 323, :end-line 323, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Run f using requestAnimationFrame or equivalent.\n\n  f will be called just before components are rendered."}, track {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 216, :column 7, :end-line 216, :end-column 12, :arglists (quote ([f & args])), :doc "Takes a function and optional arguments, and returns a derefable\n  containing the output of that function. If the function derefs\n  Reagent atoms (or track, etc), the value will be updated whenever\n  the atom changes.\n\n  In other words, @(track foo bar) will produce the same result\n  as (foo bar), but foo will only be called again when the atoms it\n  depends on changes, and will only trigger updates of components when\n  its result changes.\n\n  track is lazy, i.e the function is only evaluated on deref.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}}, :name reagent.core/track, :variadic true, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}, :method-params [(f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 216, :end-line 216, :max-fixed-arity 1, :fn-var true, :arglists ([f & args]), :doc "Takes a function and optional arguments, and returns a derefable\n  containing the output of that function. If the function derefs\n  Reagent atoms (or track, etc), the value will be updated whenever\n  the atom changes.\n\n  In other words, @(track foo bar) will produce the same result\n  as (foo bar), but foo will only be called again when the atoms it\n  depends on changes, and will only trigger updates of components when\n  its result changes.\n\n  track is lazy, i.e the function is only evaluated on deref."}, props {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 168, :column 7, :end-line 168, :end-column 12, :arglists (quote ([this])), :doc "Returns the props passed to a component."}, :name reagent.core/props, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 12, :method-params ([this]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 168, :end-line 168, :max-fixed-arity 1, :fn-var true, :arglists (quote ([this])), :doc "Returns the props passed to a component."}, dispose! {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 240, :column 7, :end-line 240, :end-column 15, :arglists (quote ([x])), :doc "Stop the result of track! from updating."}, :name reagent.core/dispose!, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 240, :end-line 240, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Stop the result of track! from updating."}, state-atom {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 127, :column 7, :end-line 127, :end-column 17, :arglists (quote ([this])), :doc "Returns an atom containing a components state."}, :name reagent.core/state-atom, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 17, :method-params ([this]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 127, :end-line 127, :max-fixed-arity 1, :fn-var true, :arglists (quote ([this])), :doc "Returns an atom containing a components state."}, flush {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 197, :column 7, :end-line 197, :end-column 12, :arglists (quote ([])), :doc "Render dirty components immediately to the DOM.\n\n  Note that this may not work in event handlers, since React.js does\n  batching of updates there."}, :name reagent.core/flush, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 12, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 197, :end-line 197, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Render dirty components immediately to the DOM.\n\n  Note that this may not work in event handlers, since React.js does\n  batching of updates there."}, children {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 174, :column 7, :end-line 174, :end-column 15, :arglists (quote ([this])), :doc "Returns the children passed to a component."}, :name reagent.core/children, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 15, :method-params ([this]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 174, :end-line 174, :max-fixed-arity 1, :fn-var true, :arglists (quote ([this])), :doc "Returns the children passed to a component."}, wrap {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 245, :column 7, :end-line 245, :end-column 11, :arglists (quote ([value reset-fn & args])), :doc "Provide a combination of value and callback, that looks like an atom.\n\n  The first argument can be any value, that will be returned when the\n  result is deref'ed.\n\n  The second argument should be a function, that is called with the\n  optional extra arguments provided to wrap, and the new value of the\n  resulting 'atom'.\n\n  Use for example like this:\n\n  (wrap (:foo @state)\n        swap! state assoc :foo)\n\n  Probably useful only for passing to child components.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(value reset-fn args)], :arglists ([value reset-fn & args]), :arglists-meta (nil)}}, :name reagent.core/wrap, :variadic true, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(value reset-fn args)], :arglists ([value reset-fn & args]), :arglists-meta (nil)}, :method-params [(value reset-fn args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 245, :end-line 245, :max-fixed-arity 2, :fn-var true, :arglists ([value reset-fn & args]), :doc "Provide a combination of value and callback, that looks like an atom.\n\n  The first argument can be any value, that will be returned when the\n  result is deref'ed.\n\n  The second argument should be a function, that is called with the\n  optional extra arguments provided to wrap, and the new value of the\n  resulting 'atom'.\n\n  Use for example like this:\n\n  (wrap (:foo @state)\n        swap! state assoc :foo)\n\n  Probably useful only for passing to child components."}, reactify-component {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 57, :column 7, :end-line 57, :end-column 25, :arglists (quote ([c])), :doc "Returns an adapter for a Reagent component, that may be used from\n  React, for example in JSX. A single argument, props, is passed to\n  the component, converted to a map."}, :name reagent.core/reactify-component, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 25, :method-params ([c]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 57, :end-line 57, :max-fixed-arity 1, :fn-var true, :arglists (quote ([c])), :doc "Returns an adapter for a Reagent component, that may be used from\n  React, for example in JSX. A single argument, props, is passed to\n  the component, converted to a map."}, unmount-component-at-node {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 78, :column 7, :end-line 78, :end-column 32, :arglists (quote ([container])), :doc "Remove a component from the given DOM node."}, :name reagent.core/unmount-component-at-node, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 32, :method-params ([container]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 78, :end-line 78, :max-fixed-arity 1, :fn-var true, :arglists (quote ([container])), :doc "Remove a component from the given DOM node."}, render-component {:name reagent.core/render-component, :file "resources/public/js/cljs-dev/reagent/core.cljs", :line 85, :column 1, :end-line 85, :end-column 22, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 85, :column 6, :end-line 85, :end-column 22}}, component-path {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 343, :column 7, :end-line 343, :end-column 21, :arglists (quote ([c]))}, :name reagent.core/component-path, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 21, :method-params ([c]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 343, :end-line 343, :max-fixed-arity 1, :fn-var true, :arglists (quote ([c]))}, cursor {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 268, :column 7, :end-line 268, :end-column 13, :arglists (quote ([src path])), :doc "Provide a cursor into a Reagent atom.\n\n  Behaves like a Reagent atom but focuses updates and derefs to\n  the specified path within the wrapped Reagent atom. e.g.,\n    (let [c (cursor ra [:nested :content])]\n      ... @c ;; equivalent to (get-in @ra [:nested :content])\n      ... (reset! c 42) ;; equivalent to (swap! ra assoc-in [:nested :content] 42)\n      ... (swap! c inc) ;; equivalence to (swap! ra update-in [:nested :content] inc)\n      )\n\n  The first parameter can also be a function, that should look\n  something like this:\n\n    (defn set-get\n      ([k] (get-in @state k))\n      ([k v] (swap! state assoc-in k v)))\n\n  The function will be called with one argument – the path passed to\n  cursor – when the cursor is deref'ed, and two arguments (path and\n  new value) when the cursor is modified.\n\n  Given that set-get function, (and that state is a Reagent atom, or\n  another cursor) these cursors are equivalent:\n  (cursor state [:foo]) and (cursor set-get [:foo]).\n\n  Note that a cursor is lazy: its value will not change until it is\n  used. This may be noticed with add-watch."}, :name reagent.core/cursor, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 13, :method-params ([src path]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 268, :end-line 268, :max-fixed-arity 2, :fn-var true, :arglists (quote ([src path])), :doc "Provide a cursor into a Reagent atom.\n\n  Behaves like a Reagent atom but focuses updates and derefs to\n  the specified path within the wrapped Reagent atom. e.g.,\n    (let [c (cursor ra [:nested :content])]\n      ... @c ;; equivalent to (get-in @ra [:nested :content])\n      ... (reset! c 42) ;; equivalent to (swap! ra assoc-in [:nested :content] 42)\n      ... (swap! c inc) ;; equivalence to (swap! ra update-in [:nested :content] inc)\n      )\n\n  The first parameter can also be a function, that should look\n  something like this:\n\n    (defn set-get\n      ([k] (get-in @state k))\n      ([k v] (swap! state assoc-in k v)))\n\n  The function will be called with one argument – the path passed to\n  cursor – when the cursor is deref'ed, and two arguments (path and\n  new value) when the cursor is modified.\n\n  Given that set-get function, (and that state is a Reagent atom, or\n  another cursor) these cursors are equivalent:\n  (cursor state [:foo]) and (cursor set-get [:foo]).\n\n  Note that a cursor is lazy: its value will not change until it is\n  used. This may be noticed with add-watch."}, state {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 133, :column 7, :end-line 133, :end-column 12, :arglists (quote ([this])), :doc "Returns the state of a component, as set with replace-state or set-state.\n  Equivalent to (deref (r/state-atom this))"}, :name reagent.core/state, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 12, :method-params ([this]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 133, :end-line 133, :max-fixed-arity 1, :fn-var true, :arglists (quote ([this])), :doc "Returns the state of a component, as set with replace-state or set-state.\n  Equivalent to (deref (r/state-atom this))"}, dom-node {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 186, :column 7, :end-line 186, :end-column 15, :arglists (quote ([this])), :doc "Returns the root DOM node of a mounted component."}, :name reagent.core/dom-node, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 15, :method-params ([this]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 186, :end-line 186, :max-fixed-arity 1, :fn-var true, :arglists (quote ([this])), :doc "Returns the root DOM node of a mounted component."}, track! {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 232, :column 7, :end-line 232, :end-column 13, :arglists (quote ([f & args])), :doc "An eager version of track. The function passed is called\n  immediately, and continues to be called when needed, until stopped\n  with dispose!.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}}, :name reagent.core/track!, :variadic true, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}, :method-params [(f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 232, :end-line 232, :max-fixed-arity 1, :fn-var true, :arglists ([f & args]), :doc "An eager version of track. The function passed is called\n  immediately, and continues to be called when needed, until stopped\n  with dispose!."}, is-client {:name reagent.core/is-client, :file "resources/public/js/cljs-dev/reagent/core.cljs", :line 17, :column 1, :end-line 17, :end-column 15, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 17, :column 6, :end-line 17, :end-column 15}, :tag boolean}, replace-state {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 140, :column 7, :end-line 140, :end-column 20, :arglists (quote ([this new-state])), :doc "Set state of a component.\n  Equivalent to (reset! (state-atom this) new-state)"}, :name reagent.core/replace-state, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 20, :method-params ([this new-state]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 140, :end-line 140, :max-fixed-arity 2, :fn-var true, :arglists (quote ([this new-state])), :doc "Set state of a component.\n  Equivalent to (reset! (state-atom this) new-state)"}, partial {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 338, :column 7, :end-line 338, :end-column 14, :arglists (quote ([f & args])), :doc "Works just like clojure.core/partial, but the result can be compared with =", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}}, :name reagent.core/partial, :variadic true, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}, :method-params [(f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 338, :end-line 338, :max-fixed-arity 1, :fn-var true, :arglists ([f & args]), :doc "Works just like clojure.core/partial, but the result can be compared with ="}, set-state {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 148, :column 7, :end-line 148, :end-column 16, :arglists (quote ([this new-state])), :doc "Merge component state with new-state.\n  Equivalent to (swap! (state-atom this) merge new-state)"}, :name reagent.core/set-state, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 16, :method-params ([this new-state]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 148, :end-line 148, :max-fixed-arity 2, :fn-var true, :arglists (quote ([this new-state])), :doc "Merge component state with new-state.\n  Equivalent to (swap! (state-atom this) merge new-state)"}, argv {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 180, :column 7, :end-line 180, :end-column 11, :arglists (quote ([this])), :doc "Returns the entire Hiccup form passed to the component."}, :name reagent.core/argv, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 11, :method-params ([this]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 180, :end-line 180, :max-fixed-arity 1, :fn-var true, :arglists (quote ([this])), :doc "Returns the entire Hiccup form passed to the component."}, render {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 65, :column 7, :end-line 65, :end-column 13, :arglists (quote ([comp container] [comp container callback])), :doc "Render a Reagent component into the DOM. The first argument may be\n  either a vector (using Reagent's Hiccup syntax), or a React element.\n  The second argument should be a DOM node.\n\n  Optionally takes a callback that is called when the component is in place.\n\n  Returns the mounted component instance.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([comp container] [comp container callback]), :arglists ([comp container] [comp container callback]), :arglists-meta (nil nil)}}, :name reagent.core/render, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([comp container] [comp container callback]), :arglists ([comp container] [comp container callback]), :arglists-meta (nil nil)}, :method-params ([comp container] [comp container callback]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 65, :end-line 65, :max-fixed-arity 3, :fn-var true, :arglists ([comp container] [comp container callback]), :doc "Render a Reagent component into the DOM. The first argument may be\n  either a vector (using Reagent's Hiccup syntax), or a React element.\n  The second argument should be a DOM node.\n\n  Optionally takes a callback that is called when the component is in place.\n\n  Returns the mounted component instance."}, force-update {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 156, :column 7, :end-line 156, :end-column 19, :arglists (quote ([this] [this deep])), :doc "Force a component to re-render immediately.\n\n  If the second argument is true, child components will also be\n  re-rendered, even is their arguments have not changed.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([this] [this deep]), :arglists ([this] [this deep]), :arglists-meta (nil nil)}}, :name reagent.core/force-update, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([this] [this deep]), :arglists ([this] [this deep]), :arglists-meta (nil nil)}, :method-params ([this] [this deep]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 156, :end-line 156, :max-fixed-arity 2, :fn-var true, :arglists ([this] [this deep]), :doc "Force a component to re-render immediately.\n\n  If the second argument is true, child components will also be\n  re-rendered, even is their arguments have not changed."}, create-class {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 102, :column 7, :end-line 102, :end-column 19, :arglists (quote ([spec])), :doc "Create a component, React style. Should be called with a map,\n  looking like this:\n\n    {:get-initial-state (fn [this])\n     :component-will-receive-props (fn [this new-argv])\n     :should-component-update (fn [this old-argv new-argv])\n     :component-will-mount (fn [this])\n     :component-did-mount (fn [this])\n     :component-will-update (fn [this new-argv])\n     :component-did-update (fn [this old-argv])\n     :component-will-unmount (fn [this])\n     :reagent-render (fn [args....])}   ;; or :render (fn [this])\n\n  Everything is optional, except either :reagent-render or :render."}, :name reagent.core/create-class, :variadic false, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 19, :method-params ([spec]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 102, :end-line 102, :max-fixed-arity 1, :fn-var true, :arglists (quote ([spec])), :doc "Create a component, React style. Should be called with a map,\n  looking like this:\n\n    {:get-initial-state (fn [this])\n     :component-will-receive-props (fn [this new-argv])\n     :should-component-update (fn [this old-argv new-argv])\n     :component-will-mount (fn [this])\n     :component-did-mount (fn [this])\n     :component-will-update (fn [this new-argv])\n     :component-did-update (fn [this old-argv])\n     :component-will-unmount (fn [this])\n     :reagent-render (fn [args....])}   ;; or :render (fn [this])\n\n  Everything is optional, except either :reagent-render or :render."}, create-element {:protocol-inline nil, :meta {:file "/home/mohamed/workspace/clojure/cljs/instatube/resources/public/js/cljs-dev/reagent/core.cljs", :line 19, :column 7, :end-line 19, :end-column 21, :arglists (quote ([type] [type props] [type props child] [type props child & children])), :doc "Create a native React element, by calling React.createElement directly.\n\n  That means the second argument must be a javascript object (or nil), and\n  that any Reagent hiccup forms must be processed with as-element. For example\n  like this:\n\n    (r/create-element \"div\" #js{:className \"foo\"}\n       \"Hi \" (r/as-element [:strong \"world!\"])\n\n  which is equivalent to\n\n    [:div.foo \"Hi\" [:strong \"world!\"]]", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([type] [type props] [type props child]), :arglists ([type] [type props] [type props child] [type props child & children]), :arglists-meta (nil nil nil nil)}}, :name reagent.core/create-element, :variadic true, :file "resources/public/js/cljs-dev/reagent/core.cljs", :end-column 21, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([type] [type props] [type props child]), :arglists ([type] [type props] [type props child] [type props child & children]), :arglists-meta (nil nil nil nil)}, :method-params ([type] [type props] [type props child]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 19, :end-line 19, :max-fixed-arity 3, :fn-var true, :arglists ([type] [type props] [type props child] [type props child & children]), :doc "Create a native React element, by calling React.createElement directly.\n\n  That means the second argument must be a javascript object (or nil), and\n  that any Reagent hiccup forms must be processed with as-element. For example\n  like this:\n\n    (r/create-element \"div\" #js{:className \"foo\"}\n       \"Hi \" (r/as-element [:strong \"world!\"])\n\n  which is equivalent to\n\n    [:div.foo \"Hi\" [:strong \"world!\"]]"}}, :cljs.spec/registry-ref [], :require-macros {reagent.core reagent.core, ratom reagent.ratom, reagent.ratom reagent.ratom, deb reagent.debug, reagent.debug reagent.debug, reagent.interop reagent.interop}, :doc nil}